package com.phdlabs.sungwon.a8chat_android.structure.camera.fragments.normal

import android.content.Context
import android.content.pm.PackageManager
import android.content.res.Configuration
import android.graphics.ImageFormat
import android.graphics.Point
import android.graphics.SurfaceTexture
import android.hardware.camera2.*
import android.hardware.camera2.params.StreamConfigurationMap
import android.media.ImageReader
import android.os.Bundle
import android.os.Handler
import android.os.HandlerThread
import android.support.v13.app.ActivityCompat
import android.support.v4.content.ContextCompat
import android.util.Size
import android.util.SparseIntArray
import android.view.*
import com.phdlabs.sungwon.a8chat_android.R
import com.phdlabs.sungwon.a8chat_android.structure.camera.fragments.CameraBaseFragment
import com.phdlabs.sungwon.a8chat_android.utility.Constants
import kotlinx.android.synthetic.main.fragment_cameranormal.*
import java.io.File
import java.util.*
import java.util.concurrent.Semaphore
import kotlin.Comparator
import kotlin.collections.ArrayList

/**
 * Created by paix on 12/28/17.
 *
 */
class NormalFragment : CameraBaseFragment(), NormalContract.View {


    /**
     * Controller
     * */
    override lateinit var controller: NormalContract.Controller

    /**
     * Camera Properties
     * */
    /*ID of the current camera device*/
    var mCameraId: String? = null
    /*Capture session for camera preview*/
    val mCaptureSession: CameraCaptureSession? = null
    /*Camera device*/
    val mCameraDevice: CameraDevice? = null
    /*Camera peview size*/
    var mPreviewSize: Size? = null

    /**
     * Image Properties
     * */
    /*Additional thread to avoid blocking the UI*/
    val mBackgroundThread: HandlerThread? = null
    /*Handler for running tasks in the background*/
    val mBackgroundHandler: Handler? = null
    /*Image reader that handles still image capturing*/
    var mImageReader: ImageReader? = null
    /*Picture output file*/
    var mFile: File? = null
    /*Capture request builder for the camera preview*/
    var mPreviewRequestBuilder: CaptureRequest.Builder? = null
    /*Capture request generated by [mPreviewCaptureRequestBuilder]*/
    var mPreviewRequest: CaptureRequest? = null
    /*The current state of the camera for taking pictures*/
    var mState: Int = STATE_PREVIEW
    /*Semaphore to prevent the app from exiting before closing the camera*/
    var mCameraOpenCloseLock: Semaphore? = null
    /*Whether the current camera supports flash or not*/
    var mFlashSupported: Boolean? = null
    /*Orientation for the caemra sensor*/
    var mSensorOrientation: Int? = null

    /*LifeCycle*/
    init {
        /*Screen rotation to JPEG rotation*/
        addOrientations()
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        /*Init controller*/
        NormalController(this)

    }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        mFile = File(activity?.getExternalFilesDir(null), "pic.jpg")
    }

    override fun onStart() {
        super.onStart()
        controller.start()
    }

    override fun onResume() {
        super.onResume()
        controller.resume()
        //TODO: startBackgroundThread()
        /*When screen is turned on & off -> SurfaceTexture is already available & will not be
        * called. We can open a camera and start preview from [onResume] || we wait until the surface
        * is ready in the surfaceTextureListener*/
        if (mTextureView.isAvailable) {
            //TODO: openCamera(mTextureView.width, mTextureView.height)
        } else {
            mTextureView.surfaceTextureListener = mSurfaceTextureListener
        }
    }

    override fun onPause() {
        super.onPause()
        controller.pause()
        //TODO: closeCamera()
        //TODO: stopBackgroundThread()
    }


    override fun onStop() {
        super.onStop()
        controller.stop()
    }

    /*Layout*/
    override fun cameraLayoutId(): Int = R.layout.fragment_cameranormal

    override fun inOnCreateView(root: View?, container: ViewGroup?, savedInstanceState: Bundle?) {
    }

    /*Results*/
    override fun onRequestPermissionsResult(requestCode: Int, permissions: Array<out String>, grantResults: IntArray) {
        if (requestCode == Constants.PermissionsReqCode.CAMERA_REQ_CODE) {
            if (grantResults.size != 1 || grantResults.get(0) != PackageManager.PERMISSION_GRANTED) {
                showError(getString(R.string.request_camera_permission))
            }
        } else {
            super.onRequestPermissionsResult(requestCode, permissions, grantResults)
        }
    }


    /**
     * Companion
     * */
    companion object {

        /*instance*/
        fun create(): NormalFragment = NormalFragment()

        /*Screen Rotation to JPEG conversion*/
        var ORIENTATIONS: SparseIntArray = SparseIntArray()

        fun addOrientations() {
            ORIENTATIONS.append(Surface.ROTATION_0, 90)
            ORIENTATIONS.append(Surface.ROTATION_90, 0)
            ORIENTATIONS.append(Surface.ROTATION_180, 270)
            ORIENTATIONS.append(Surface.ROTATION_270, 180)
        }

        /*Camera permissions*/
        var REQUEST_CAMERA_PERMISSION = 1 //TODO: Change camera permissions -> Constants

        /*Dialog*/
        var FRAGMENT_DIALOG = "dialog"

        /**
         * Camera States
         * */
        private val STATE_PREVIEW: Int = 0 //Showing camera preview
        private val STATE_WAITING_LOCK: Int = 1 // Waiting for the focus to be locked
        private val STATE_WAITING_PRECAPTURE: Int = 2 // Waiting for the exposure to be in pre-capture state
        private val STATE_WAITING_NON_PRECAPTURE: Int = 3 // Waiting for the exposure state to be anything but pre-capture
        private val STATE_PICTURE_TAKEN: Int = 4 // Picture was taken
        private val MAX_PREVIEW_WIDTH = 1920 // Max preview width guaranteed by camera API-2
        private val MAX_PREVIEW_HEIGHT = 1080 // Max preview height guaranteed by camera API -2


        /**
         * [chooseOptimalSize]
         * Resolutions for the available SurfaceView
         * From the given choices supported by the camera, choose the smallest one that is at least as
         * large as the texture view size, and as large as the respective maximum size. If such size
         * doesn't exist, it will choose the largest one that is at most as large as the respective
         * maximum size, and matches with the aspect ratio of the specified value
         * @param choices
         * @param textureViewWidth
         * @param textureViewHeight
         * @param maxWidth
         * @param maxHeight
         * @param aspectRatio
         * @return optimal size or an arbitrary one if none were big enough
         * */
        private fun chooseOptimalSize(choices: Array<out Size>, textureViewWidth: Int, textureViewHeight: Int,
                                      maxWidth: Int, maxHeight: Int, aspectRatio: Size): Size? {
            //collect supported resolutions that are at least as big as the preview surface
            val bigEnough: ArrayList<Size> = ArrayList<Size>()
            //collect supported resolutions that are smaller than the preview surface
            val smallEnough: ArrayList<Size> = ArrayList<Size>()
            //Width & Height
            val width: Int = aspectRatio.width
            val height: Int = aspectRatio.height
            choices
                    .filter { it.width <= maxWidth && it.height <= maxHeight && it.height == (it.width * height / width) }
                    .forEach {
                        if (it.width >= textureViewWidth &&
                                it.height >= textureViewHeight) {
                            bigEnough.add(it)
                        } else {
                            smallEnough.add(it)
                        }
                    }
            //Pick the smallest for the smallEnough
            if (bigEnough.size > 0) {
                //TODO: compareSizesByArea()
                //return Collections.min(bigEnough, CompareSizesByArea())
            } else if (smallEnough.size > 0) {
                //TODO: compareSizesByArea()
                //return Collections.max(smallEnough, CompareSizesByArea())
            } else {
                return choices[0]
            }
            return null
        }

        /**
         * Compares two sizes based on their areas
         * [CompareSizesByArea]
         * */
        class CompareSizesByArea : Comparator<Size> {
            override fun compare(p0: Size?, p1: Size?): Int {
                //Cast to avoid overflow with multipliers
                var compare: Int = 0
                p0?.let {
                    p1?.let {
                        compare = java.lang.Long.signum(p0.width.toLong() * p0.height -
                                p1.width.toLong() * p1.height)
                    }
                }
                return compare
            }

        }


    }//end companion

    /**
     * [mSurfaceTextureListener]
     * SurfaceTextureListener for handling lifecycle events on the TextureView
     * @Link TextureView
     * */
    private val mSurfaceTextureListener = object : TextureView.SurfaceTextureListener {
        override fun onSurfaceTextureSizeChanged(p0: SurfaceTexture?, p1: Int, p2: Int) {
            //TODO: configureTransform(width, height)
        }

        override fun onSurfaceTextureUpdated(p0: SurfaceTexture?) {
        }

        override fun onSurfaceTextureDestroyed(p0: SurfaceTexture?): Boolean = true

        override fun onSurfaceTextureAvailable(p0: SurfaceTexture?, p1: Int, p2: Int) {
            //TODO: openCamera(width, height)
        }
    }


    //TODO: Finish implementing Camera Device State Callback
    /**
     * [mStateCallback]
     * Camera state callback changes when the Camera device changes state
     * */
    private val mStateCallback = object : CameraDevice.StateCallback() {

        override fun onOpened(p0: CameraDevice?) {
            TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
        }

        override fun onDisconnected(p0: CameraDevice?) {
            TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
        }

        override fun onError(p0: CameraDevice?, p1: Int) {
            TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
        }

    }

    /**
     * [mOnImageAvailableListener]
     * Callback object for the [ImageReader] which is called when a still image is ready to be saved
     * */
    private val mOnImageAvailableListener = object : ImageReader.OnImageAvailableListener {
        override fun onImageAvailable(p0: ImageReader?) {
            TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
            //TODO: post imageSaver
        }
    }

    /**
     * [CameraCaptureSession.CaptureCallback] handling the events related to the JPEG capture
     * */

    private val mCaptureCallback = object : CameraCaptureSession.CaptureCallback() {

        fun process(captureResult: CaptureResult?) {
            when (mState) {

                STATE_PREVIEW -> {
                    /*Do nothing when camera preview is working*/
                    return
                }

                STATE_WAITING_LOCK -> {
                    /*AutoFocus*/
                    val afState: Int? = captureResult?.get(CaptureResult.CONTROL_AF_STATE)
                    afState?.let {
                        if (it == (CaptureResult.CONTROL_AF_STATE_FOCUSED_LOCKED) ||
                                it == (CaptureResult.CONTROL_AF_STATE_NOT_FOCUSED_LOCKED)) {
                            /*AutoExposure -> Can be null on some devices*/
                            val aeState: Int? = captureResult.get(CaptureResult.CONTROL_AE_STATE)
                            if (aeState == null || aeState == CaptureResult.CONTROL_AE_STATE_CONVERGED) {
                                mState = STATE_PICTURE_TAKEN
                                //TODO: captureStillPicture()
                            } else {
                                //TODO: runPrecaptureSequence()
                            }
                        }
                    } ?: run {
                        //TODO: captureStillPicture()
                    }
                    return
                }

                STATE_WAITING_PRECAPTURE -> {
                    /*AutoFocus -> can be null on some devices*/
                    val aeState: Int? = captureResult?.get(CaptureResult.CONTROL_AE_STATE)
                    if (aeState == null ||
                            aeState == CaptureResult.CONTROL_AE_STATE_PRECAPTURE ||
                            aeState == CaptureRequest.CONTROL_AE_STATE_FLASH_REQUIRED) {
                        mState = STATE_WAITING_NON_PRECAPTURE
                    }
                    return
                }

                STATE_WAITING_NON_PRECAPTURE -> {
                    /*AutoFocus -> can be null on some devices*/
                    val aeState: Int? = captureResult?.get(CaptureResult.CONTROL_AE_STATE)
                    if (aeState == null ||
                            aeState != CaptureResult.CONTROL_AE_STATE_PRECAPTURE) {
                        mState = STATE_PICTURE_TAKEN
                        //TODO: captureStillPicture()
                    }
                    return
                }

            }
        }

        /*required*/
        override fun onCaptureProgressed(session: CameraCaptureSession?, request: CaptureRequest?, partialResult: CaptureResult?) {
            process(partialResult)
        }

        /*required*/
        override fun onCaptureCompleted(session: CameraCaptureSession?, request: CaptureRequest?, result: TotalCaptureResult?) {
            process(result)
        }

    }

    /**Camera permissions
     * [requestCameraPermissions]
     * //TODO: Add permissions for Audio Recording & Video Recording
     * Request Camera, Audio & Video
     * */
    private fun requestCameraPermissions() {
        //Required permissions
        val whatPermissions = arrayOf(Constants.AppPermissions.CAMERA)
        context?.let {
            //Request Permissions
            if (ContextCompat.checkSelfPermission(it, whatPermissions.get(0)) != PackageManager.PERMISSION_GRANTED) {
                activity?.let {
                    ActivityCompat.requestPermissions(it, whatPermissions, Constants.PermissionsReqCode.CAMERA_REQ_CODE)
                }
            }
        }
    }

    /**Setup member variables for the camera
     * <FullScreen>
     * [setupCameraOutputs]
     * @param width The width of available size for camera preview
     * @param height The height of available size for camera preview
     * */
    private fun setupCameraOutputs(width: Int, height: Int) {

        activity?.let {
            val manager: CameraManager = it.getSystemService(Context.CAMERA_SERVICE) as CameraManager
            try {
                loop@ for (cameraId: String in manager.cameraIdList) {
                    val characteristics: CameraCharacteristics = manager.getCameraCharacteristics(cameraId)
                    //TODO: Front face camera is not yet supported

                    val facing = characteristics.get(CameraCharacteristics.LENS_FACING)
                    if (facing == null || facing != CameraCharacteristics.LENS_FACING_FRONT) {
                        break@loop
                    }
                    val map: StreamConfigurationMap = characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP)

                    //For still image captures, we use the largest available size
                    val largest = Collections.max(
                            Arrays.asList(*map.getOutputSizes(ImageFormat.JPEG)),
                            CompareSizesByArea())
                    mImageReader = ImageReader.newInstance(largest.width, largest.height, ImageFormat.JPEG, 2)
                    mImageReader?.setOnImageAvailableListener(mOnImageAvailableListener, mBackgroundHandler)

                    //Find out if we need to swap dimension to get the preview size relative to the sensor coordinate
                    val displayRotation = it.windowManager.defaultDisplay.rotation

                    //non-inspection constants conditions
                    mSensorOrientation = characteristics.get(CameraCharacteristics.SENSOR_ORIENTATION)
                    var swappedDimensions: Boolean = false

                    when (displayRotation) {
                        Surface.ROTATION_0 -> {/*Do nothing*/
                        }
                        Surface.ROTATION_180 -> {
                            if (mSensorOrientation == 90 || mSensorOrientation == 270) {
                                swappedDimensions = true
                            }
                        }
                        Surface.ROTATION_90 -> {/*Do nothing*/
                        }
                        Surface.ROTATION_270 -> {
                            if (mSensorOrientation == 0 || mSensorOrientation == 180) {
                                swappedDimensions = true
                            }
                        }
                    }

                    //Size & Rotation
                    val displaySize: Point = Point()
                    it.windowManager.defaultDisplay.getSize(displaySize)
                    var rotatedPreviewWidth = width
                    var rotatedPreviewHeight = height
                    var maxPreviewWidth = displaySize.x
                    var maxPreviewHeight = displaySize.y
                    if(swappedDimensions) {
                        rotatedPreviewWidth = height
                        rotatedPreviewHeight = width
                        maxPreviewWidth = displaySize.y
                        maxPreviewHeight = displaySize.x
                    }
                    if(maxPreviewWidth > MAX_PREVIEW_WIDTH) {
                        maxPreviewWidth = MAX_PREVIEW_WIDTH
                    }
                    if(maxPreviewHeight > MAX_PREVIEW_HEIGHT) {
                        maxPreviewHeight = MAX_PREVIEW_HEIGHT
                    }

                    /*
                    * Important:
                    * attempting to use a very large preview size could exceed the camera bus
                    * band-with & result in great previews with garbage captured data
                    * */
                    mPreviewSize = chooseOptimalSize(map.getOutputSizes(SurfaceTexture::class.java),
                            rotatedPreviewWidth, rotatedPreviewHeight, maxPreviewWidth,
                            maxPreviewHeight, largest)

                    //Fit the aspect ratio of TextureView ot the size of preview picked
                    val orientation = resources.configuration.orientation
                    if(orientation == Configuration.ORIENTATION_LANDSCAPE){
                        mPreviewSize?.let {
                            mTextureView.setAspectRatio(it.width, it.height)
                        }
                    } else {
                        mPreviewSize?.let {
                            mTextureView.setAspectRatio(it.height, it.width)
                        }
                    }

                    //Check if the flash is supported
                    //TODO: Manage the flash manually
                    val available = characteristics.get(CameraCharacteristics.FLASH_INFO_AVAILABLE)
                    mFlashSupported = available

                    //Camera hardware id
                    mCameraId = cameraId
                    return
                }
            } catch (e: CameraAccessException) {
                e.printStackTrace()
            } catch (e: NullPointerException) {
                showError(getString(R.string.camera_error))
            }
        }
    }

    //TODO: Open Camera



}
